---
title: "基础研究方法与假设检验"
output:
  word_document: default
  html_document:
    df_print: paged
---

# T-test

测试两组之间的平均数差异

让我们从加载我们需要开始的包开始吧

首先介绍下我们这次利用的数据库，BOSTON， 该数据集包含美国人口普查局收集的有关波士顿马萨诸塞州住房的信息，该数据集是从[StatLib档案库](http://lib.stat.cmu.edu/datasets/boston)获得的。在数据分析教学中得到了广泛的使用。

CRIM -- -- 按城市分列的人均犯罪率。
ZN--被划为25,000平方英尺以上地段的住宅用地比例。
INDUS--每个城镇非零售商业用地的比例。
CHAS - 查尔斯河虚拟变量（如果地块与河流相邻，则为1；否则为0）。
NOX -- -- 一氧化氮浓度(千万分之一)
RM -- -- 每套住宅的平均房间数。
AGE ----1940年以前建成的业主自住单位的比例。
DIS----到波士顿五个就业中心的加权距离。
RAD -- -- 辐射状公路的可进入性指数。
TAX ----每10 000美元的全值财产税率。
PTRATIO -- -- 按城市分列的学生-教师比率
BLACK -- 其为各镇的黑人比例。
LSTAT -- -- 人口中地位较低的人所占百分比
MEDV -- -- 自住房屋的中位值（以千美元计）。

Boston数据为MASS包内置数据，可以直接输入Boston 调取.
调取MASS包，并将Boston数据赋值给df变量
通过summary函数，我们可以快速浏览数据库内变量的基本信息。

```{r message=FALSE, warning=FALSE}
library()
df <- 
summary()
```

听
# T-test via t.test()

统计学中最常见的检验方法之一是T检验，用于确定两组的平均值是否相等。检验的假设是两组都是从方差相等的正态分布中抽样出来的，零假设是两组均值相等，另一个假设是两组均值不相等。检验的零假设是两组均值相等，另一假设是两组均值不相等。众所周知，在零假设下，我们可以计算一个t统计量，它将遵循n1+n2-2个自由度的t分布。还有一种被广泛使用的t检验的修改，称为Welch's t检验，当认为方差不相等时，可以调整自由度数。在我们进一步探讨这个检验之前，我们需要找到一个简单的方法来计算t统计量。


t.test() 函数的使用方式是 t.test(x, y = NULL, alternative = c("two.sided", "less", "greater"), mu = 0, paired = FALSE, var.equal = FALSE,  conf.level = 0.95)。 其中X为必须参数。其余参数如果不单独设置就会以提前默认值输入。 

x	
一个（非空）数据值的数字向量。

y	
一个可选的（非空）数据值的数字向量。

alternative	
指定替代假设的字符串，必须是 "two.sided"（默认）、"greater "或 "less "中的一个。您可以只指定首字母。

mu	
表示平均数的真实值的数字（如果您进行的是两个样本测试，则表示平均数的差异）。

paired	
表示是否要进行配对T检验的逻辑。

var.equal	
一个逻辑变量，表示是否将两个方差视为相等。如果为TRUE，则使用集合方差来估计方差，否则使用Welch（或Satterthwaite）近似的自由度。

conf.level	
区间的置信度

## 单一样本T检验

**假设该区域总体的平均犯罪率为2.6, 那么在该α=0.05情况下该样本数据的犯罪率平均值是否在统计学意义上不同于区域平均值？**

H0: 样本数据的犯罪率在统计学意义上与区域平均值相同
Ha: 样本数据的犯罪率在统计学意义上与区域平均值不同

```{r}
t.test(, mu = )
```
结果得到p-value = 0.008289 <0.05, 因此拒绝空假设H0，样本数据的犯罪率在统计学意义上不同于区域的总体平均数。
假设该区域总体的平均犯罪率为3.5呢?

```{r}
t.test()
```
结果得到p-value = 0.7667 > 0.05, 因此拒绝空假设H0，样本数据的犯罪率在统计学意义上与区域的总体平均数相同。


## 双样本T检验

要运行两个样本的t检验，我们依然可以简单地使用该t.test()函数
**这次我们来检测，地块与查尔斯河相邻是否会对房价产生影响。**
变量为数据中的medv 与chas 两个变量，分别记录了房价和地块是否与查尔斯河相邻

R可以根据分类自动帮助你来分组，只需要用“因变量~自变量”的格式。

H0:  查尔斯河相邻和非相邻的地块房价在统计学意义上相同
Ha:  查尔斯河相邻和非相邻的地块房价在统计学意义上不相同


第一步先是检验两组数据的异方差性
```{r}
var.test()
```
p-value = 0.009 <0.05, 因此两组的方差并不相同。这样t.test函数中我们需要将 var.equal 参数设置为FALSE. 同样t,test 也可以采用“因变量~自变量”的格式
另外我们可以将计算的结果赋值给某个变量，然后用print()函数进行展示

```{r}
model = 
print(model)
```
p-value =0.003 <0.05 , 因此我们可以拒绝空假设。 查尔斯河相邻和非相邻的地块房价在统计学意义上不相同。

另外我可以用ggplot包中的qplot函数将不同组的数据的数据分布进行可视化。 

```{r}
# Density plots
qplot(fill = as.factor(), x = , data = , geom = "density", 
      alpha = I(0.5),
      adjust = 1.5)
```

## 依存/匹配T检验

Boston 数据中每条记录都是独立的，因此我们需要自己模拟一个数据库来展示才做方式。
假设有一种超人药品在一组小白鼠身上进行试验，然后观察他们吃药前后体重的变化
因为两组样本实际上是针对同一组小白鼠在实验前后的数据。因此这里就需要用到匹配T检验
首先来构建数据

```{r}
# Data in two numeric vectors
# ++++++++++++++++++++++++++
# Weight of the mice before treatment
before <-c(200.1, 190.9, 192.7, 213, 241.4, 196.9, 172.2, 185.5, 205.2, 193.7)
# Weight of the mice after treatment
after <-c(392.9, 190.9, 345.1, 393, 434, 427.9, 422, 383.9, 205.2, 352.2)
```

我们可以借助 PairedData 包进行匹配数据的可视化

```{r}
library(PairedData)
pd <- (before, after) #用paired函数进行配对
plot(pd, type = "profile") + theme_bw()
```

这里的假设是
H0：实验前与试验后小白鼠体重相同，药效不存在
Ha：实验前与试验后小白鼠体重不相同，药效存在

因为是双样本比较，因此依然需要先测试异方差性。

```{r}
var.test(, )
```
p-value < 0.05 因此可以认为两组的方差有明显统计学差异。

因为是匹配T检验，因此t.test函数中paired函数要设置为True,  var.equal 为 FALSE ，其余默认
```{r}
t.test()
```

结果得到p-value < 0.05, 因此拒绝空假设H0。实验前与试验后小白鼠体重不相同，药效存在

# ANOVA

这一章节我们会用到R里面另外一个常用经典数据集 iris. Iris Dataset（鸢尾属植物数据集）是现在接触到的历史最悠久的数据集之一，它首次出现在著名的英国统计学家和生物学家Ronald Fisher 1936年的论文《The use of multiple measurements in taxonomic problems》中。在这个数据集中，包括了三类不同的鸢尾属植物：Iris Setosa，Iris Versicolour，Iris Virginica。每类收集了50个样本，因此这个数据集一共包含了150个样本。数据记录了每个样本的四类特征 sepal length（花萼长度), sepal width（花萼宽度),petal length（花瓣长度）,petal width（花瓣宽度）

**因此这里我们要检验三种花在花萼长度上有没有统计学意义上的区别。**
H0：三种花在花萼长度上有没有统计学意义上的区别。
Ha：三种花在花萼长度上不是没有统计学意义上的区别。至少一种花与其他花在花萼长度上是统计学意义上的区别。

首先将内置数据赋给df，并用summary函数进行初步观察

```{r}
df <- iris 
summary()
```

然后我们可以通过图表快速观察不同花的花萼长度分布
```{r}
boxplot()
qplot(fill = as.factor(), x = , data = , geom = "density", 
      alpha = I(0.5),
      adjust = 1.5)

```
之后可以开始ANOVA方差分析，R中ANOVA检测主要使用的是aov() 函数,与T检验一样我们可以使用 “因变量~自变量”的格式输入参数。但值得注意的是，不同于T检验，直接调用函数不会给出结果，因此我们还要用summary()函数来显示出带有p-value的结果

```{r}
iris.aov <- aov(Sepal.Length ~ Species , data =df )
summary(iris.aov)

```
从结果得出 p-value <0.05， 因此我们拒绝H0，三种花在花萼长度上不是没有统计学意义上的区别。

## 事后比较
方差分析无法指出具体是哪种花在统计学上有区别，因此需要事后比较分析。
在r里函数是TukeyHSD(), 它会将所有组进行两两自动比较。

```{r}
TukeyHSD(iris.aov, data =df)
```
从结果可知三种花的花萼长度在两两对比当中都有出统计学意义上的显著不同


# 卡方分析

卡方分析中我们将利用另一个数据库survey, 该数据调研了某个学校237学生的基本信息。在数据中，Smoke列记录了学生的吸烟习惯，Exer列记录了他们的运动水平。Smoke的允许值为 "Heavy"、"Regul"（经常）、"Occas"（偶尔）和 "Never"。至于Exer，则是 "Freq"（经常）、"Some "和 "None"。

**这里我们要在0.05的显著性水平下，检验学生的吸烟习惯是否与运动水平无关。**
首先还是将survey数据赋值给df变量

```{r}
df
```

第一步我们可以用R中的表格函数将学生的吸烟习惯与运动水平进行统计，其结果称为两个变量的交叉分组表。

```{r}
tbl <- table(,)
tbl                 
```
之后R里可以用chisq.test()函数对于交叉分组表进行卡方检验

```{r}
(tbl) 
```
由于Pvalue = 0.4828 > 0.05的显著性水平，因此我们无法拒绝H0。样本里学生吸烟习惯与运动水平没有统计学上的相关性。

有些人会质疑结果不存在关系是因为吸烟的分类过于繁琐。因此我们进一步合并吸烟水平，仅分成吸烟与不吸烟两类。再重新进行卡方分析。

```{r}
#数据进行重新归类，把1,3,4行数据求和，再去第2行重新合并成表格
rtbl = rbind() 
#查看rtbl数据

#对rtbl数据进行卡方检测

```
结果中p-value 依然大于0.05，我们仍然无法拒绝H0，因此结论不变。


# 相关性分析

相关性中我们重新采用之前见过的Boston数据, 去**观察数据集内部变量之间的相关性**。

```{r}
df <- Boston
```

在R中相关性分析的函数是cor(),对于两个单独的变量使用方法如下。比如我们想看房屋价格与地区犯罪率之间的关系

```{r}
cor()
```
结果显示出一个中等的负相关性，意味着随犯罪率的上升，该地区的房屋价格会下降。

对于相关性表,我们同样是采用cor()函数，直接输入想观察的数据集即可。

```{r}
#对整个df的所有变量进行相关性检验

```
一大堆数字铺面而来有点懵对吧。 虽然相关性表是很长一段时间文章中主流的表达方式，但是随着可视化技术的发展现在相关性图一般可以更好的帮助我们理解数据变量间的相关性。
这里我们需要借助一个新的包，叫corrplot
```{r}
#读取corrplot包

#用corrplot函数对相关性表进行可视化

```
因此在图中我们可以更直观的看到那些变量的相关性更强。

corrplot函数提供不同风格的结果只需要修改method参数即可， 包括"circle" (default), "square", "ellipse", "number", "pie", "shade" and "color"
比如采用color模式

```{r}
#采用color模式对相关性表进行可视化
corrplot(cor(Boston), method="color")
#尝试其他模式


```

